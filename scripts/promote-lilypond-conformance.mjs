/* global console */

import { mkdir, readdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';
import { TextDecoder } from 'node:util';
import { parse as parseYaml } from 'yaml';

import { parseMusicXML, parseMusicXMLAsync, renderToSVGPages } from '../dist/public/index.js';

/** Absolute repository root path derived from script location. */
const ROOT_DIR = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..');
/** Canonical collated-suite manifest generated by `corpus:lilypond:sync`. */
const CORPUS_MANIFEST_PATH = path.join(ROOT_DIR, 'fixtures', 'corpus', 'lilypond-collated-v2.25.json');
/** Output directory for LilyPond conformance fixtures. */
const LILYPOND_CONFORMANCE_DIR = path.join(ROOT_DIR, 'fixtures', 'conformance', 'lilypond');

/** Parse CLI flags for optional batch limits and dry-run behavior. */
function parseArgs(argv) {
  const args = {
    limit: Number.POSITIVE_INFINITY,
    dryRun: false
  };

  for (let index = 0; index < argv.length; index += 1) {
    const token = argv[index];
    if (token === '--limit') {
      const value = Number(argv[index + 1] ?? '');
      if (Number.isFinite(value) && value > 0) {
        args.limit = value;
      }
      index += 1;
      continue;
    }
    if (token === '--dry-run') {
      args.dryRun = true;
    }
  }

  return args;
}

/** Load JSON from disk and parse it into an object. */
async function readJson(filePath) {
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

/** Convert source names like `24a-GraceNotes.xml` into filesystem-safe slugs. */
function toLocalBaseName(sourceName) {
  return sourceName
    .toLowerCase()
    .replace(/\.(xml|mxl)$/i, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/** Return output score extension for one source file name. */
function toLocalScoreExtension(sourceName) {
  return sourceName.toLowerCase().endsWith('.mxl') ? 'mxl' : 'musicxml';
}

/** Return true if this fixture already has metadata in the conformance directory. */
function isFixtureAlreadyImported(existingMetaBasenames, sourceName) {
  return existingMetaBasenames.has(toLocalBaseName(sourceName));
}

/** Convert byte payload to parse/render observation for expected-state classification. */
async function classifyFixture(sourceName, payload) {
  const isCompressed = sourceName.toLowerCase().endsWith('.mxl');
  const parseResult = isCompressed
    ? await parseMusicXMLAsync(
        {
          data: payload,
          format: 'mxl'
        },
        {
          sourceName,
          mode: 'lenient'
        }
      )
    : parseMusicXML(new TextDecoder().decode(payload), { sourceName, mode: 'lenient' });

  const parseErrorCodes = parseResult.diagnostics
    .filter((diagnostic) => diagnostic.severity === 'error')
    .map((diagnostic) => diagnostic.code);

  /** @type {string[]} */
  const failureReasons = [];
  if (!parseResult.score) {
    failureReasons.push('parse returned no score');
  }
  if (parseErrorCodes.length > 0) {
    failureReasons.push(`parse errors: ${Array.from(new Set(parseErrorCodes)).join(',')}`);
  }

  /** @type {string[]} */
  const renderErrorCodes = [];
  if (parseResult.score) {
    try {
      const renderResult = renderToSVGPages(parseResult.score);
      renderErrorCodes.push(
        ...renderResult.diagnostics
          .filter((diagnostic) => diagnostic.severity === 'error')
          .map((diagnostic) => diagnostic.code)
      );
      if (renderResult.pages.length === 0) {
        failureReasons.push('render returned zero pages');
      }
      if (renderErrorCodes.length > 0) {
        failureReasons.push(`render errors: ${Array.from(new Set(renderErrorCodes)).join(',')}`);
      }
    } catch (error) {
      failureReasons.push(`render throw: ${String(error?.code ?? error?.message ?? error)}`);
    }
  }

  const observed = failureReasons.length === 0 ? 'pass' : 'fail';
  return { observed, failureReasons };
}

/** Quote values for safe YAML scalar serialization. */
function quoteYaml(value) {
  return `"${String(value).replaceAll('\\', '\\\\').replaceAll('"', '\\"')}"`;
}

/** Build metadata text for a classified fixture. */
function buildMetaText(fixture, classification) {
  const lines = [
    `id: lilypond-${toLocalBaseName(fixture.sourceName)}`,
    `source: ${fixture.sourceUrl}`,
    `category: lilypond-${fixture.categoryId}`,
    `expected: ${classification.observed}`,
    'status: active',
    'parse_mode: lenient'
  ];

  if (classification.observed === 'pass') {
    lines.push('notes: "M7A bulk-import auto-classified as pass (lenient parse/render succeeded)."');
  } else {
    lines.push(`notes: ${quoteYaml(`M7A bulk-import auto-classified fail: ${classification.failureReasons.join('; ')}`)}`);
    // Every expected-fail fixture must link a tracked risk/todo by policy.
    lines.push('linked_todo: R-002');
  }

  return `${lines.join('\n')}\n`;
}

/** Persist fixture score payload and generated metadata sidecar files. */
async function writeFixtureFiles(fixture, payload, metaText) {
  const basename = toLocalBaseName(fixture.sourceName);
  const extension = toLocalScoreExtension(fixture.sourceName);
  const scorePath = path.join(LILYPOND_CONFORMANCE_DIR, `${basename}.${extension}`);
  const metaPath = path.join(LILYPOND_CONFORMANCE_DIR, `${basename}.meta.yaml`);
  await writeFile(scorePath, payload);
  await writeFile(metaPath, metaText, 'utf8');
}

/** Import and classify all remaining LilyPond fixtures not already present locally. */
async function main() {
  const args = parseArgs(process.argv.slice(2));
  const manifest = await readJson(CORPUS_MANIFEST_PATH);

  await mkdir(LILYPOND_CONFORMANCE_DIR, { recursive: true });
  const existingEntries = await readdir(LILYPOND_CONFORMANCE_DIR);
  const existingMetaBasenames = new Set(
    existingEntries
      .filter((entry) => entry.endsWith('.meta.yaml'))
      .map((entry) => entry.replace(/\.meta\.yaml$/i, ''))
  );
  const existingSourceUrls = new Set();
  for (const entry of existingEntries.filter((name) => name.endsWith('.meta.yaml'))) {
    const metaPath = path.join(LILYPOND_CONFORMANCE_DIR, entry);
    const raw = await readFile(metaPath, 'utf8');
    const parsed = parseYaml(raw);
    if (parsed && typeof parsed === 'object' && typeof parsed.source === 'string') {
      existingSourceUrls.add(parsed.source);
    }
  }

  const remainingFixtures = manifest.fixtures.filter(
    (fixture) =>
      !isFixtureAlreadyImported(existingMetaBasenames, fixture.sourceName) &&
      !existingSourceUrls.has(fixture.sourceUrl)
  );

  const targetFixtures = remainingFixtures.slice(0, args.limit);
  let importedCount = 0;
  let passCount = 0;
  let failCount = 0;

  for (const fixture of targetFixtures) {
    const response = await globalThis.fetch(fixture.sourceUrl);
    if (!response.ok) {
      throw new Error(`download failed for ${fixture.sourceName} (${response.status} ${response.statusText})`);
    }

    const payload = new Uint8Array(await response.arrayBuffer());
    const classification = await classifyFixture(fixture.sourceName, payload);
    const metaText = buildMetaText(fixture, classification);

    if (!args.dryRun) {
      await writeFixtureFiles(fixture, payload, metaText);
    }

    importedCount += 1;
    if (classification.observed === 'pass') {
      passCount += 1;
    } else {
      failCount += 1;
    }

    console.log(
      `${args.dryRun ? '[dry-run] ' : ''}${fixture.sourceName} -> expected ${classification.observed}${
        classification.failureReasons.length > 0 ? ` (${classification.failureReasons.join('; ')})` : ''
      }`
    );
  }

  console.log(
    `${args.dryRun ? '[dry-run] ' : ''}Promoted ${importedCount} fixture(s): ${passCount} pass / ${failCount} fail`
  );
}

await main();
