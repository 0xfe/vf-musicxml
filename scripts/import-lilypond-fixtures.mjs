/* global console */

import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { fileURLToPath } from 'node:url';

/** Absolute repository root for stable path resolution regardless of current cwd. */
const ROOT_DIR = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..');
/** Canonical corpus manifest generated by `corpus:lilypond:sync`. */
const DEFAULT_CORPUS_MANIFEST_PATH = path.join(ROOT_DIR, 'fixtures', 'corpus', 'lilypond-collated-v2.25.json');
/** Default conformance output location for imported LilyPond fixtures. */
const DEFAULT_OUTPUT_DIR = path.join(ROOT_DIR, 'fixtures', 'conformance', 'lilypond');

/**
 * Parse CLI arguments into an options object.
 * Supported options:
 * - `--cases`: comma-separated case IDs (`12a,14a,21a`) or source names (`12a-Clefs.xml`)
 * - `--status`: `active` or `skip`
 * - `--expected`: `pass` or `fail`
 * - `--parse-mode`: `lenient` or `strict`
 * - `--notes`: free-form metadata note
 * - `--linked-todo`: optional todo id
 * - `--out-dir`: output fixture directory
 * - `--manifest`: corpus manifest path
 */
function parseArgs(argv) {
  const options = {
    cases: [],
    status: 'active',
    expected: 'pass',
    parseMode: 'lenient',
    notes: 'Imported from canonical LilyPond corpus manifest.',
    linkedTodo: undefined,
    outDir: DEFAULT_OUTPUT_DIR,
    manifestPath: DEFAULT_CORPUS_MANIFEST_PATH
  };

  for (let index = 0; index < argv.length; index += 1) {
    const token = argv[index];
    if (token === '--cases') {
      const raw = argv[index + 1] ?? '';
      options.cases = raw
        .split(',')
        .map((value) => value.trim())
        .filter((value) => value.length > 0);
      index += 1;
      continue;
    }
    if (token === '--status') {
      options.status = argv[index + 1] ?? options.status;
      index += 1;
      continue;
    }
    if (token === '--expected') {
      options.expected = argv[index + 1] ?? options.expected;
      index += 1;
      continue;
    }
    if (token === '--parse-mode') {
      options.parseMode = argv[index + 1] ?? options.parseMode;
      index += 1;
      continue;
    }
    if (token === '--notes') {
      options.notes = argv[index + 1] ?? options.notes;
      index += 1;
      continue;
    }
    if (token === '--linked-todo') {
      options.linkedTodo = argv[index + 1] ?? options.linkedTodo;
      index += 1;
      continue;
    }
    if (token === '--out-dir') {
      options.outDir = path.resolve(ROOT_DIR, argv[index + 1] ?? options.outDir);
      index += 1;
      continue;
    }
    if (token === '--manifest') {
      options.manifestPath = path.resolve(ROOT_DIR, argv[index + 1] ?? options.manifestPath);
      index += 1;
      continue;
    }
  }

  return options;
}

/** Read and parse JSON from disk as UTF-8 text. */
async function readJson(filePath) {
  const { readFile } = await import('node:fs/promises');
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

/** Resolve a fixture selector token (caseId or source name) to a corpus fixture record. */
function resolveFixture(manifest, token) {
  const lowered = token.toLowerCase();
  const fixtureByCase = manifest.fixtures.find((fixture) => fixture.caseId.toLowerCase() === lowered);
  if (fixtureByCase) {
    return fixtureByCase;
  }

  return manifest.fixtures.find((fixture) => fixture.sourceName.toLowerCase() === lowered);
}

/** Convert one corpus source name into a stable local basename. */
function toLocalBaseName(sourceName) {
  return sourceName
    .toLowerCase()
    .replace(/\.(xml|mxl)$/i, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/** Select local score extension based on fixture source file type. */
function toLocalScoreExtension(sourceName) {
  return sourceName.toLowerCase().endsWith('.mxl') ? 'mxl' : 'musicxml';
}

/** Quote YAML scalar when needed to keep metadata valid and deterministic. */
function quoteYamlScalar(value) {
  return `"${String(value).replaceAll('"', '\\"')}"`;
}

/** Download one fixture payload as bytes. */
async function downloadFixtureBytes(sourceUrl) {
  const response = await globalThis.fetch(sourceUrl);
  if (!response.ok) {
    throw new Error(`failed to download ${sourceUrl} (${response.status} ${response.statusText})`);
  }
  return new Uint8Array(await response.arrayBuffer());
}

/** Build metadata text for one imported fixture. */
function buildMetadataText(fixture, options) {
  const lines = [
    `id: lilypond-${toLocalBaseName(fixture.sourceName)}`,
    `source: ${fixture.sourceUrl}`,
    `category: lilypond-${fixture.categoryId}`,
    `expected: ${options.expected}`,
    `status: ${options.status}`,
    `parse_mode: ${options.parseMode}`,
    `notes: ${quoteYamlScalar(options.notes)}`
  ];

  if (options.linkedTodo) {
    lines.push(`linked_todo: ${options.linkedTodo}`);
  }

  return `${lines.join('\n')}\n`;
}

/** Import selected fixtures into the configured conformance output directory. */
async function importFixtures(manifest, options) {
  if (options.cases.length === 0) {
    throw new Error('no cases provided; pass --cases with comma-separated case IDs');
  }
  if (!['active', 'skip'].includes(options.status)) {
    throw new Error(`invalid --status '${options.status}'`);
  }
  if (!['pass', 'fail'].includes(options.expected)) {
    throw new Error(`invalid --expected '${options.expected}'`);
  }
  if (!['lenient', 'strict'].includes(options.parseMode)) {
    throw new Error(`invalid --parse-mode '${options.parseMode}'`);
  }

  await mkdir(options.outDir, { recursive: true });

  const imported = [];

  for (const token of options.cases) {
    const fixture = resolveFixture(manifest, token);
    if (!fixture) {
      throw new Error(`fixture selector '${token}' not found in corpus manifest`);
    }

    const baseName = toLocalBaseName(fixture.sourceName);
    const scoreExtension = toLocalScoreExtension(fixture.sourceName);
    const scorePath = path.join(options.outDir, `${baseName}.${scoreExtension}`);
    const metaPath = path.join(options.outDir, `${baseName}.meta.yaml`);

    const payload = await downloadFixtureBytes(fixture.sourceUrl);
    await writeFile(scorePath, payload);
    await writeFile(metaPath, buildMetadataText(fixture, options), 'utf8');

    imported.push({ token, scorePath, metaPath });
  }

  return imported;
}

/** Entrypoint to import a batch of fixtures from corpus selectors. */
async function main() {
  const options = parseArgs(process.argv.slice(2));
  const manifest = await readJson(options.manifestPath);
  const imported = await importFixtures(manifest, options);

  console.log(
    `Imported ${imported.length} LilyPond fixture(s) into ${options.outDir}: ${imported
      .map((entry) => path.basename(entry.scorePath))
      .join(', ')}`
  );
}

await main();
