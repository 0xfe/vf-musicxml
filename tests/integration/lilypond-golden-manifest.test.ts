import { access, readFile } from 'node:fs/promises';
import path from 'node:path';

import { describe, expect, it } from 'vitest';
import { loadConformanceFixtures } from '../../src/testkit/conformance.js';

/** Golden manifest path generated by `npm run golden:sync`. */
const LILYPOND_GOLDEN_MANIFEST_PATH = path.resolve('fixtures/golden/manifest.json');

/** Minimal typed fixture record used for golden-manifest assertions. */
interface GoldenFixtureRecord {
  id: string;
  caseId: string;
  categoryId: string;
  status: 'active' | 'skip';
  expected: 'pass' | 'fail';
  goldenImageUrl: string;
  goldenImagePath: string;
  goldenImageSha256: string;
  referenceKind: 'lilypond-v2.24' | 'lilypond-v2.25-fallback';
}

/** Minimal typed manifest shape used by tests. */
interface GoldenManifest {
  schemaVersion: number;
  suite: {
    sourceUrl: string;
    version: string;
    fallbackSourceUrl: string;
  };
  fixtures: GoldenFixtureRecord[];
}

/** Read and parse JSON from disk with strict UTF-8 semantics. */
async function readJson<T>(filePath: string): Promise<T> {
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw) as T;
}

describe('lilypond golden manifest', () => {
  it('maps every active LilyPond conformance fixture to a local golden image', async () => {
    const manifest = await readJson<GoldenManifest>(LILYPOND_GOLDEN_MANIFEST_PATH);
    const conformanceFixtures = await loadConformanceFixtures(path.resolve('fixtures/conformance'));
    const activeLilyPondFixtures = conformanceFixtures.filter(
      (fixture) => fixture.meta.category.startsWith('lilypond-') && fixture.meta.status === 'active'
    );

    expect(manifest.schemaVersion).toBe(1);
    expect(manifest.suite.sourceUrl).toContain('lilypond.org/doc/v2.24');
    expect(manifest.suite.version).toBe('2.24');
    expect(manifest.suite.fallbackSourceUrl).toContain('lilypond.org/doc/v2.25');
    expect(manifest.fixtures.length).toBe(activeLilyPondFixtures.length);

    const manifestById = new Map(manifest.fixtures.map((fixture) => [fixture.id, fixture]));
    for (const fixture of activeLilyPondFixtures) {
      const goldenFixture = manifestById.get(fixture.meta.id);
      expect(goldenFixture, `missing golden mapping for ${fixture.meta.id}`).toBeDefined();
    }
  });

  it('keeps golden-image links, checksums, and category fields normalized', async () => {
    const manifest = await readJson<GoldenManifest>(LILYPOND_GOLDEN_MANIFEST_PATH);
    const seenIds = new Set<string>();

    for (const fixture of manifest.fixtures) {
      expect(seenIds.has(fixture.id), `fixture id '${fixture.id}' should be unique`).toBe(false);
      seenIds.add(fixture.id);

      expect(fixture.status).toBe('active');
      expect(fixture.categoryId.startsWith('lilypond-')).toBe(true);
      expect(fixture.caseId).toMatch(/^\d{2}[a-z]$/);
      expect(fixture.goldenImageUrl.startsWith('https://lilypond.org/')).toBe(true);
      expect(fixture.goldenImageUrl.endsWith('.png')).toBe(true);
      expect(fixture.goldenImagePath.startsWith('fixtures/golden/lilypond-v2.24/')).toBe(true);
      expect(fixture.goldenImageSha256).toMatch(/^[a-f0-9]{64}$/);
      expect(['lilypond-v2.24', 'lilypond-v2.25-fallback']).toContain(fixture.referenceKind);

      await expect(access(path.resolve(fixture.goldenImagePath))).resolves.toBeUndefined();
    }
  });
});
