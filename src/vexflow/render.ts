import { JSDOM } from 'jsdom';
import {
  BarlineType,
  Beam,
  Formatter,
  Renderer,
  Stave,
  StaveConnector,
  type StaveConnectorType,
  type StaveNote,
  Voice,
  VoltaType
} from 'vexflow';

import type { Diagnostic } from '../core/diagnostics.js';
import type { ClefInfo, Measure, Part, PartDefinition, Score } from '../core/score.js';
import { ensureDomGlobals } from './render-dom.js';
import {
  buildVoiceEventKey,
  buildMeasureNotes,
  mapClef,
  mapKeySignature,
  mapTimeSignature,
  parseTime
} from './render-note-mapper.js';
import {
  drawMeasureDirections,
  drawMeasureHarmonies,
  drawMeasureLyrics,
  drawMeasureTuplets,
  drawScoreSpanners,
  registerMeasureEventNotes,
  type RenderMeasureWindow
} from './render-notations.js';
import {
  DEFAULT_PAGE_HEIGHT,
  DEFAULT_PAGE_WIDTH,
  DEFAULT_PAGINATED_PAGE_HEIGHT,
  DEFAULT_PAGINATED_PAGE_WIDTH,
  LEFT_MARGIN,
  TOP_MARGIN,
  type RenderLayoutMode,
  type RenderOptionsLike,
  type RenderPagesResultLike,
  type RenderToElementResultLike
} from './render-types.js';

export type { RenderOptionsLike, RenderPagesResultLike, RenderToElementResultLike } from './render-types.js';

/** Vertical distance between staves in one rendered system row. */
const STAFF_ROW_HEIGHT = 110;
/** Extra vertical spacing between parts after staff rows are placed. */
const PART_GAP = 30;
/** Minimum measure width used by formatter planning for readability. */
const MINIMUM_MEASURE_WIDTH = 160;
/** Minimum measure width used when forced to fit many measures in one system. */
const MINIMUM_FITTED_MEASURE_WIDTH = 82;
/** Default gap between systems when not explicitly configured. */
const DEFAULT_SYSTEM_GAP = 40;
/** Default label column width for part/staff names. */
const DEFAULT_LABEL_WIDTH = 86;
/** Approximate character width multiplier for text placement without `measureText`. */
const TEXT_WIDTH_FACTOR = 0.56;
/** Damping factor used when compensating first-column width for system-start modifiers. */
const FIRST_COLUMN_EXTRA_WIDTH_DAMPING = 0.6;
/** Ignore small first-column shifts that do not materially hurt readability. */
const FIRST_COLUMN_EXTRA_IGNORE_RATIO = 0.12;
/** Clamp first-column compensation so opening measures are not over-expanded. */
const FIRST_COLUMN_EXTRA_WIDTH_CAP_RATIO = 0.32;

/** Stable layout metadata for one score part across all systems/pages. */
interface PartLayout {
  part: Part;
  staffCount: number;
}

/** First-column stave bounds for one rendered part, used by group connectors. */
interface PartBoundary {
  topStave: Stave;
  bottomStave: Stave;
}

/** Horizontal layout information for one system's measure columns. */
interface MeasureColumnLayout {
  columnX: number[];
  columnWidths: number[];
  totalWidth: number;
}

/** One measure-range system generated by the page planner. */
interface SystemRange {
  index: number;
  startMeasure: number;
  endMeasure: number;
  forcePageBreakBefore?: boolean;
}

/** One placed system row on a rendered page. */
interface PageSystemPlacement extends SystemRange {
  topY: number;
}

/** One rendered page with packed systems and explicit page number. */
interface PagePlan {
  pageNumber: number;
  systems: PageSystemPlacement[];
}

/** Resolved and normalized page margins used by all layout modes. */
interface ResolvedMargins {
  top: number;
  right: number;
  bottom: number;
  left: number;
}

/** Normalized layout options that the renderer uses during planning/drawing. */
interface LayoutPlanConfig {
  mode: RenderLayoutMode;
  pageWidth: number;
  pageHeight: number;
  margins: ResolvedMargins;
  contentStartX: number;
  contentWidth: number;
  measuresPerSystem: number;
  systemGap: number;
  topSystemOffset: number;
  staffRowHeight: number;
  partGap: number;
  justifyLastSystem: boolean;
  showPartNames: boolean;
  showPartAbbreviations: boolean;
  repeatOnSystemBreak: boolean;
  labelWidth: number;
  showTitle: boolean;
  showMovementTitle: boolean;
  showPageNumber: boolean;
  leftHeader?: string;
  rightHeader?: string;
  leftFooter?: string;
  rightFooter?: string;
}

/** Forced line/page break starts collected from parsed MusicXML `<print>` directives. */
interface ForcedMeasureBreaks {
  systemStarts: Set<number>;
  pageStarts: Set<number>;
}

/** Earliest print-level page layout hints used as global pagination defaults. */
interface InitialPrintPageLayout {
  pageWidth?: number;
  pageHeight?: number;
  margins?: ResolvedMargins;
}

/** Runtime render metrics for one page after system layouts are resolved. */
interface PageRenderEnvelope {
  width: number;
  height: number;
}

/** CSS class used to identify deterministic page background rects in SVG output. */
const PAGE_BACKGROUND_CLASS = 'mx-page-background';
/** Fixed page background color to avoid transparent/black viewer output differences. */
const PAGE_BACKGROUND_FILL = '#ffffff';

/**
 * Render score content to SVG page strings.
 * This path is deterministic for headless tests and now defaults to paginated
 * rendering while preserving a horizontal continuous mode.
 */
export function renderScoreToSVGPages(
  score: Score,
  options: RenderOptionsLike = {}
): RenderPagesResultLike {
  const diagnostics: Diagnostic[] = [];

  if (options.backend === 'canvas') {
    diagnostics.push({
      code: 'CANVAS_NOT_SUPPORTED_IN_M2',
      severity: 'warning',
      message: 'Canvas backend is not implemented in M2. Falling back to SVG.'
    });
  }

  const dom = new JSDOM('<!doctype html><html><body><div id="root"></div></body></html>');
  const container = dom.window.document.getElementById('root');

  if (!container) {
    diagnostics.push({
      code: 'SVG_CONTAINER_ERROR',
      severity: 'error',
      message: 'Unable to initialize SVG rendering container.'
    });
    return {
      pages: [],
      diagnostics
    };
  }

  const pageCount = renderIntoContainer(score, container as unknown as HTMLElement, options, diagnostics);
  const svgPages = [...container.querySelectorAll('svg')].map((svgElement) => svgElement.outerHTML);
  dom.window.close();

  return {
    pages: pageCount > 0 ? svgPages : [],
    diagnostics
  };
}

/**
 * Render score content into a caller-provided container.
 * Useful for browser use-cases that need live DOM nodes instead of raw strings.
 */
export function renderScoreToElement(
  score: Score,
  container: HTMLElement,
  options: RenderOptionsLike = {}
): RenderToElementResultLike {
  const diagnostics: Diagnostic[] = [];
  const pageCount = renderIntoContainer(score, container, options, diagnostics);

  return {
    pageCount,
    diagnostics,
    dispose: () => {
      container.innerHTML = '';
    }
  };
}

/** Shared render implementation used by both string and DOM entry points. */
function renderIntoContainer(
  score: Score,
  container: HTMLElement,
  options: RenderOptionsLike,
  diagnostics: Diagnostic[]
): number {
  const restoreDomGlobals = ensureDomGlobals(container.ownerDocument);
  container.innerHTML = '';

  if (score.parts.length === 0) {
    diagnostics.push({
      code: 'EMPTY_SCORE',
      severity: 'error',
      message: 'Score does not contain any parts to render.'
    });
    return 0;
  }

  const measureCount = Math.max(0, ...score.parts.map((part) => part.measures.length));
  if (measureCount === 0) {
    diagnostics.push({
      code: 'EMPTY_PART',
      severity: 'error',
      message: 'Score parts contain no measures to render.'
    });
    return 0;
  }

  const partLayouts = buildPartLayouts(score.parts);
  const config = resolveLayoutPlanConfig(score, options, partLayouts, measureCount);
  const forcedBreaks = collectForcedMeasureBreaks(partLayouts, measureCount);
  const systemRanges = buildSystemRanges(measureCount, config, forcedBreaks);
  const systemHeight = estimateSystemHeight(partLayouts, config);
  const pagePlans = buildPagePlans(score, systemRanges, systemHeight, config);

  const partDefinitionsById = new Map(score.partList.map((definition) => [definition.id, definition]));

  try {
    for (const pagePlan of pagePlans) {
      const hostDiv = container.ownerDocument.createElement('div');
      container.appendChild(hostDiv);

      const systemColumnLayouts = new Map<number, MeasureColumnLayout>();
      let pageMaxContentRight = config.contentStartX;
      for (const system of pagePlan.systems) {
        const columnLayout = buildMeasureColumnLayoutForSystem(
          score,
          partLayouts,
          system,
          config.contentStartX,
          config.contentWidth,
          config.mode === 'paginated',
          config.justifyLastSystem && system.endMeasure >= measureCount,
          diagnostics
        );
        systemColumnLayouts.set(system.index, columnLayout);
        pageMaxContentRight = Math.max(pageMaxContentRight, config.contentStartX + columnLayout.totalWidth);
      }

      const envelope = resolvePageRenderEnvelope(score, pagePlan, pageMaxContentRight, systemHeight, config);
      const renderer = new Renderer(hostDiv, Renderer.Backends.SVG);
      renderer.resize(envelope.width, envelope.height);
      const context = renderer.getContext();
      ensurePageBackgroundRect(hostDiv, envelope);

      drawPageHeaderFooter(context, score, pagePlan.pageNumber, pagePlans.length, envelope.width, envelope.height, config);

      const eventNotesByPart = new Map<string, Map<string, StaveNote>>();

      for (const system of pagePlan.systems) {
        const partBoundaries = new Map<string, PartBoundary>();
        let globalTopStave: Stave | undefined;
        let globalBottomStave: Stave | undefined;
        let partCursorY = system.topY;
        const columnLayout = systemColumnLayouts.get(system.index);
        if (!columnLayout) {
          continue;
        }

        for (const partLayout of partLayouts) {
          const partEventNotes = eventNotesByPart.get(partLayout.part.id) ?? new Map<string, StaveNote>();
          eventNotesByPart.set(partLayout.part.id, partEventNotes);

          for (let measureColumn = system.startMeasure; measureColumn < system.endMeasure; measureColumn += 1) {
            const localColumnIndex = measureColumn - system.startMeasure;
            const x = columnLayout.columnX[localColumnIndex] ?? config.contentStartX;
            const columnWidth = columnLayout.columnWidths[localColumnIndex] ?? MINIMUM_MEASURE_WIDTH;
            const measure = partLayout.part.measures[measureColumn];
            const staves: Stave[] = [];
            const isSystemStartColumn = measureColumn === system.startMeasure;

            for (let staffNumber = 1; staffNumber <= partLayout.staffCount; staffNumber += 1) {
              const y = partCursorY + (staffNumber - 1) * config.staffRowHeight;
              const stave = new Stave(x, y, columnWidth);
              const clefInfo = resolveClefForStaff(measure, staffNumber);
              const clef = mapClef(clefInfo, diagnostics);
              const key = mapKeySignature(measure?.effectiveAttributes.keySignature);
              const time = mapTimeSignature(measure?.effectiveAttributes.timeSignature);

              if (isSystemStartColumn) {
                stave.addClef(clef);
                if (staffNumber === 1) {
                  if (key) {
                    stave.addKeySignature(key);
                  }
                  if (time) {
                    stave.addTimeSignature(time);
                  }
                }
              }

              if (measure) {
                applyMeasureBarlineSemantics(stave, measure, staffNumber);
              }

              stave.setContext(context).draw();
              staves.push(stave);

              if (!measure) {
                continue;
              }

              const noteResult = buildMeasureNotes(measure, score.ticksPerQuarter, clef, diagnostics, staffNumber);
              if (noteResult.notes.length > 0) {
                registerMeasureEventNotes(partEventNotes, partLayout.part.id, measure.index, noteResult);

                const [numBeats, beatValue] = parseTime(measure.effectiveAttributes.timeSignature);
                const voice = new Voice({ num_beats: numBeats, beat_value: beatValue }).setMode(Voice.Mode.SOFT);
                voice.addTickables(noteResult.notes);

                formatVoiceToStave(voice, stave, diagnostics, measure.index, staffNumber);
                const beams = prepareMeasureBeams(
                  measure,
                  noteResult.notes,
                  noteResult.noteByEventKey,
                  diagnostics,
                  measure.index,
                  staffNumber
                );
                voice.draw(context, stave);
                drawPreparedBeams(beams, context, diagnostics, measure.index, staffNumber);
                drawMeasureTuplets(noteResult.tuplets, diagnostics, context);
              }

              if (staffNumber === 1) {
                drawMeasureDirections(measure, stave, score.ticksPerQuarter, diagnostics);
              }

              drawMeasureHarmonies(
                measure,
                stave,
                score.ticksPerQuarter,
                staffNumber,
                noteResult.noteByEventKey,
                diagnostics
              );
              drawMeasureLyrics(measure, stave, staffNumber, noteResult.noteByEventKey, diagnostics);
            }

            if (staves.length > 1) {
              const topStave = staves[0];
              const bottomStave = staves[staves.length - 1];
              if (topStave && bottomStave) {
                drawConnector(topStave, bottomStave, 'singleLeft', context);
                if (isSystemStartColumn) {
                  drawConnector(topStave, bottomStave, 'brace', context);
                }
              }
            }

            if (isSystemStartColumn && staves.length > 0) {
              const topStave = staves[0];
              const bottomStave = staves[staves.length - 1];
              if (!topStave || !bottomStave) {
                continue;
              }

              partBoundaries.set(partLayout.part.id, {
                topStave,
                bottomStave
              });

              if (!globalTopStave) {
                globalTopStave = topStave;
              }
              globalBottomStave = bottomStave;
            }
          }

          const boundary = partBoundaries.get(partLayout.part.id);
          if (boundary) {
            drawPartLabel(
              context,
              partDefinitionsById.get(partLayout.part.id),
              system.index,
              boundary.topStave.getY() + 18,
              config
            );
          }

          partCursorY += partLayout.staffCount * config.staffRowHeight + config.partGap;
        }

        const groupConnectorCount = drawPartGroupConnectors(score, partLayouts, partBoundaries, context);
        if (groupConnectorCount === 0 && score.parts.length > 1 && globalTopStave && globalBottomStave) {
          drawConnector(globalTopStave, globalBottomStave, 'bracket', context);
        }
      }

      const renderWindow = resolvePageMeasureWindow(pagePlan);
      for (const [partId, partEventNotes] of eventNotesByPart.entries()) {
        drawScoreSpanners(score, partId, partEventNotes, diagnostics, context, renderWindow);
      }
    }
  } finally {
    restoreDomGlobals();
  }

  return pagePlans.length;
}

/** Resolve one inclusive measure window for all systems on the current page. */
function resolvePageMeasureWindow(pagePlan: PagePlan): RenderMeasureWindow | undefined {
  if (pagePlan.systems.length === 0) {
    return undefined;
  }

  let startMeasure = Number.POSITIVE_INFINITY;
  let endMeasure = Number.NEGATIVE_INFINITY;
  for (const system of pagePlan.systems) {
    startMeasure = Math.min(startMeasure, system.startMeasure);
    endMeasure = Math.max(endMeasure, system.endMeasure);
  }

  if (!Number.isFinite(startMeasure) || !Number.isFinite(endMeasure)) {
    return undefined;
  }

  return {
    startMeasure,
    endMeasure
  };
}

/**
 * Inject an explicit white page background into the generated SVG.
 * Many viewers render transparent backgrounds as dark/black; this keeps screenshots
 * and visual comparisons stable across tooling and platforms.
 */
function ensurePageBackgroundRect(hostDiv: HTMLElement, envelope: PageRenderEnvelope): void {
  const svg = hostDiv.querySelector('svg');
  if (!svg) {
    return;
  }

  const rect = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rect.setAttribute('class', PAGE_BACKGROUND_CLASS);
  rect.setAttribute('x', '0');
  rect.setAttribute('y', '0');
  rect.setAttribute('width', String(Math.ceil(envelope.width)));
  rect.setAttribute('height', String(Math.ceil(envelope.height)));
  rect.setAttribute('fill', PAGE_BACKGROUND_FILL);
  rect.setAttribute('stroke', 'none');

  svg.insertBefore(rect, svg.firstChild);
}

/** Resolve one clef assignment for a staff, falling back to first-known clef. */
function resolveClefForStaff(measure: Measure | undefined, staffNumber: number): ClefInfo | undefined {
  if (!measure) {
    return undefined;
  }

  return (
    measure.effectiveAttributes.clefs.find((clef) => clef.staff === staffNumber) ??
    measure.effectiveAttributes.clefs[staffNumber - 1] ??
    measure.effectiveAttributes.clefs[0]
  );
}

/** Precompute staff-count envelopes per part for page/system planning. */
function buildPartLayouts(parts: Part[]): PartLayout[] {
  return parts.map((part) => ({
    part,
    staffCount: Math.max(1, ...part.measures.map((measure) => Math.max(1, measure.effectiveAttributes.staves)))
  }));
}

/** Collect forced system/page starts from parsed measure print directives across parts. */
function collectForcedMeasureBreaks(partLayouts: PartLayout[], measureCount: number): ForcedMeasureBreaks {
  const systemStarts = new Set<number>();
  const pageStarts = new Set<number>();

  for (let measureIndex = 0; measureIndex < measureCount; measureIndex += 1) {
    let forceSystem = false;
    let forcePage = false;

    for (const layout of partLayouts) {
      const measure = layout.part.measures[measureIndex];
      if (!measure?.print) {
        continue;
      }

      forceSystem ||= Boolean(measure.print.newSystem || measure.print.newPage);
      forcePage ||= Boolean(measure.print.newPage);
    }

    if (measureIndex > 0 && forceSystem) {
      systemStarts.add(measureIndex);
    }
    if (measureIndex > 0 && forcePage) {
      pageStarts.add(measureIndex);
    }
  }

  return {
    systemStarts,
    pageStarts
  };
}

/** Resolve earliest `<print><page-layout>` hints as fallback pagination geometry. */
function resolveInitialPrintPageLayout(partLayouts: PartLayout[]): InitialPrintPageLayout | undefined {
  let earliest: {
    measureIndex: number;
    pageWidth?: number;
    pageHeight?: number;
    margins?: ResolvedMargins;
  } | undefined;

  for (const layout of partLayouts) {
    for (const measure of layout.part.measures) {
      if (!measure?.print) {
        continue;
      }

      const hasLayout =
        measure.print.pageWidth !== undefined ||
        measure.print.pageHeight !== undefined ||
        measure.print.pageMargins !== undefined;
      if (!hasLayout) {
        continue;
      }

      if (!earliest || measure.index < earliest.measureIndex) {
        earliest = {
          measureIndex: measure.index,
          pageWidth: measure.print.pageWidth,
          pageHeight: measure.print.pageHeight,
          margins: measure.print.pageMargins
            ? {
                top: measure.print.pageMargins.top ?? TOP_MARGIN,
                right: measure.print.pageMargins.right ?? LEFT_MARGIN,
                bottom: measure.print.pageMargins.bottom ?? 52,
                left: measure.print.pageMargins.left ?? LEFT_MARGIN
              }
            : undefined
        };
      }
    }
  }

  if (!earliest) {
    return undefined;
  }

  return {
    pageWidth: earliest.pageWidth,
    pageHeight: earliest.pageHeight,
    margins: earliest.margins
  };
}

/** Build normalized render configuration from API options and legacy flags. */
function resolveLayoutPlanConfig(
  score: Score,
  options: RenderOptionsLike,
  partLayouts: PartLayout[],
  measureCount: number
): LayoutPlanConfig {
  const explicitMode = options.layout?.mode;
  const mode: RenderLayoutMode =
    explicitMode ?? (options.paginate === false ? 'horizontal-continuous' : 'paginated');
  const initialPrintLayout = resolveInitialPrintPageLayout(partLayouts);
  const defaultPageWidth = score.defaults?.pageWidth;
  const defaultPageHeight = score.defaults?.pageHeight;
  const defaultMargins = score.defaults?.pageMargins;
  const defaultSystemMargins = score.defaults?.systemMargins;
  const defaultSystemDistance = score.defaults?.systemDistance;
  const defaultTopSystemDistance = score.defaults?.topSystemDistance;
  const defaultStaffDistance = score.defaults?.staffDistance;
  const pageWidth =
    options.layout?.page?.width ??
    options.page?.width ??
    initialPrintLayout?.pageWidth ??
    defaultPageWidth ??
    (mode === 'paginated' ? DEFAULT_PAGINATED_PAGE_WIDTH : DEFAULT_PAGE_WIDTH);
  const pageHeight =
    options.layout?.page?.height ??
    options.page?.height ??
    initialPrintLayout?.pageHeight ??
    defaultPageHeight ??
    (mode === 'paginated' ? DEFAULT_PAGINATED_PAGE_HEIGHT : DEFAULT_PAGE_HEIGHT);

  const margins: ResolvedMargins = {
    top:
      options.layout?.page?.margins?.top ??
      initialPrintLayout?.margins?.top ??
      defaultMargins?.top ??
      TOP_MARGIN,
    right:
      options.layout?.page?.margins?.right ??
      initialPrintLayout?.margins?.right ??
      defaultMargins?.right ??
      LEFT_MARGIN,
    bottom:
      options.layout?.page?.margins?.bottom ??
      initialPrintLayout?.margins?.bottom ??
      defaultMargins?.bottom ??
      52,
    left:
      options.layout?.page?.margins?.left ??
      initialPrintLayout?.margins?.left ??
      defaultMargins?.left ??
      LEFT_MARGIN
  };

  const showPartNames = options.layout?.labels?.showPartNames ?? true;
  const showPartAbbreviations = options.layout?.labels?.showPartAbbreviations ?? true;
  const repeatOnSystemBreak = options.layout?.labels?.repeatOnSystemBreak ?? true;
  const labelWidth =
    partLayouts.length > 0 && (showPartNames || showPartAbbreviations)
      ? options.layout?.labels?.labelWidth ?? DEFAULT_LABEL_WIDTH
      : 0;
  const hasSourceSystemMargins =
    Number.isFinite(defaultSystemMargins?.left) || Number.isFinite(defaultSystemMargins?.right);
  const reserveLabelColumn = !hasSourceSystemMargins;
  const systemLeftMargin = defaultSystemMargins?.left ?? 0;
  const systemRightMargin = defaultSystemMargins?.right ?? 0;
  const contentStartX = margins.left + systemLeftMargin + (reserveLabelColumn ? labelWidth : 0);
  const contentRightEdge = pageWidth - margins.right - systemRightMargin;
  const contentWidth = Math.max(MINIMUM_MEASURE_WIDTH, contentRightEdge - contentStartX);
  const userTargetMeasures = options.layout?.system?.targetMeasuresPerSystem;
  const autoMeasuresPerSystem = Math.max(1, Math.floor(contentWidth / MINIMUM_MEASURE_WIDTH));
  const measuresPerSystem =
    mode === 'horizontal-continuous'
      ? measureCount
      : clampInt(userTargetMeasures ?? autoMeasuresPerSystem, 1, measureCount);

  const hasAnyPageText =
    Boolean(options.layout?.headerFooter?.leftHeader) ||
    Boolean(options.layout?.headerFooter?.rightHeader) ||
    Boolean(options.layout?.headerFooter?.leftFooter) ||
    Boolean(options.layout?.headerFooter?.rightFooter) ||
    Boolean(score.metadata?.headerLeft) ||
    Boolean(score.metadata?.headerRight) ||
    Boolean(score.metadata?.workTitle) ||
    Boolean(score.metadata?.movementTitle);

  const hasDefaultStaffDistance = Number.isFinite(defaultStaffDistance) && (defaultStaffDistance ?? 0) > 0;
  const staffRowHeight = hasDefaultStaffDistance
    ? clampInt(Math.round(defaultStaffDistance ?? STAFF_ROW_HEIGHT), 48, 140)
    : STAFF_ROW_HEIGHT;
  const partGap = hasDefaultStaffDistance ? 0 : PART_GAP;

  return {
    mode,
    pageWidth,
    pageHeight,
    margins,
    contentStartX,
    contentWidth,
    measuresPerSystem,
    systemGap: options.layout?.system?.minSystemGap ?? defaultSystemDistance ?? DEFAULT_SYSTEM_GAP,
    topSystemOffset: defaultTopSystemDistance ?? 0,
    staffRowHeight,
    partGap,
    justifyLastSystem: options.layout?.system?.justifyLastSystem ?? true,
    showPartNames,
    showPartAbbreviations,
    repeatOnSystemBreak,
    labelWidth,
    showTitle: options.layout?.headerFooter?.showTitle ?? hasAnyPageText,
    showMovementTitle: options.layout?.headerFooter?.showMovementTitle ?? hasAnyPageText,
    showPageNumber: options.layout?.headerFooter?.showPageNumber ?? hasAnyPageText,
    leftHeader: options.layout?.headerFooter?.leftHeader ?? score.metadata?.headerLeft,
    rightHeader: options.layout?.headerFooter?.rightHeader ?? score.metadata?.headerRight,
    leftFooter: options.layout?.headerFooter?.leftFooter,
    rightFooter: options.layout?.headerFooter?.rightFooter
  };
}

/** Build contiguous measure ranges to be drawn as individual systems. */
function buildSystemRanges(
  measureCount: number,
  config: LayoutPlanConfig,
  forcedBreaks: ForcedMeasureBreaks
): SystemRange[] {
  if (config.mode === 'horizontal-continuous') {
    return [
      {
        index: 0,
        startMeasure: 0,
        endMeasure: measureCount
      }
    ];
  }

  const ranges: SystemRange[] = [];
  let cursor = 0;
  let index = 0;
  while (cursor < measureCount) {
    const next = resolveSystemEndMeasure(cursor, measureCount, config.measuresPerSystem, forcedBreaks.systemStarts);
    ranges.push({
      index,
      startMeasure: cursor,
      endMeasure: next,
      forcePageBreakBefore: cursor > 0 && forcedBreaks.pageStarts.has(cursor)
    });
    cursor = next;
    index += 1;
  }

  return ranges;
}

/** Resolve one system end, clamping to forced new-system/new-page starts. */
function resolveSystemEndMeasure(
  startMeasure: number,
  measureCount: number,
  measuresPerSystem: number,
  forcedSystemStarts: Set<number>
): number {
  const tentativeEnd = Math.min(measureCount, startMeasure + measuresPerSystem);
  let forcedEnd = tentativeEnd;

  for (const forcedStart of forcedSystemStarts) {
    if (forcedStart > startMeasure && forcedStart <= forcedEnd) {
      forcedEnd = Math.min(forcedEnd, forcedStart);
    }
  }

  if (forcedEnd <= startMeasure) {
    return Math.min(measureCount, startMeasure + 1);
  }

  return forcedEnd;
}

/** Estimate one system height from part/staff envelopes. */
function estimateSystemHeight(partLayouts: PartLayout[], config: LayoutPlanConfig): number {
  if (partLayouts.length === 0) {
    return 0;
  }

  let height = 0;
  for (let index = 0; index < partLayouts.length; index += 1) {
    const layout = partLayouts[index];
    if (!layout) {
      continue;
    }
    height += layout.staffCount * config.staffRowHeight;
    if (index < partLayouts.length - 1) {
      height += config.partGap;
    }
  }

  return height;
}

/** Pack systems into pages according to available page vertical space. */
function buildPagePlans(
  score: Score,
  systemRanges: SystemRange[],
  systemHeight: number,
  config: LayoutPlanConfig
): PagePlan[] {
  const pages: PagePlan[] = [];
  let currentPageNumber = 1;
  let currentPage: PagePlan = { pageNumber: currentPageNumber, systems: [] };
  let currentY =
    config.margins.top + estimateHeaderHeight(score, config, currentPageNumber) + config.topSystemOffset;
  let usableBottom = config.pageHeight - config.margins.bottom - estimateFooterHeight(config);

  for (const range of systemRanges) {
    if (range.forcePageBreakBefore && currentPage.systems.length > 0) {
      pages.push(currentPage);
      currentPageNumber += 1;
      currentPage = { pageNumber: currentPageNumber, systems: [] };
      currentY =
        config.margins.top + estimateHeaderHeight(score, config, currentPageNumber) + config.topSystemOffset;
      usableBottom = config.pageHeight - config.margins.bottom - estimateFooterHeight(config);
    }

    const requiredBottom = currentY + systemHeight;
    const hasExistingSystems = currentPage.systems.length > 0;
    if (requiredBottom > usableBottom && hasExistingSystems) {
      pages.push(currentPage);
      currentPageNumber += 1;
      currentPage = { pageNumber: currentPageNumber, systems: [] };
      currentY =
        config.margins.top + estimateHeaderHeight(score, config, currentPageNumber) + config.topSystemOffset;
      usableBottom = config.pageHeight - config.margins.bottom - estimateFooterHeight(config);
    }

    currentPage.systems.push({
      ...range,
      topY: currentY
    });

    currentY += systemHeight + config.systemGap;
  }

  if (currentPage.systems.length > 0) {
    pages.push(currentPage);
  }

  return pages;
}

/** Resolve actual renderer width/height needed for one page plan. */
function resolvePageRenderEnvelope(
  score: Score,
  pagePlan: PagePlan,
  maxContentRight: number,
  systemHeight: number,
  config: LayoutPlanConfig
): PageRenderEnvelope {
  const headerHeight = estimateHeaderHeight(score, config, pagePlan.pageNumber);
  const footerHeight = estimateFooterHeight(config);
  const systemBottom =
    pagePlan.systems.length > 0
      ? pagePlan.systems[pagePlan.systems.length - 1]!.topY + systemHeight
      : config.margins.top + headerHeight;

  const minimumHeight = Math.ceil(systemBottom + footerHeight + config.margins.bottom);
  const height = Math.max(config.pageHeight, minimumHeight);

  if (config.mode === 'horizontal-continuous') {
    return {
      width: Math.max(config.pageWidth, Math.ceil(maxContentRight + config.margins.right)),
      height
    };
  }

  return {
    width: config.pageWidth,
    height
  };
}

/** Estimate top header block height from enabled title/header fields. */
function estimateHeaderHeight(score: Score, config: LayoutPlanConfig, pageNumber: number): number {
  let height = 0;
  const headerLineCount = Math.max(countTextLines(config.leftHeader), countTextLines(config.rightHeader));
  const hasTitle = pageNumber === 1 && config.showTitle && Boolean(score.metadata?.workTitle);
  const hasMovement = pageNumber === 1 && config.showMovementTitle && Boolean(score.metadata?.movementTitle);

  if (headerLineCount > 0) {
    height += headerLineCount * 12 + 4;
  }
  if (hasTitle) {
    height += 28;
  }
  if (hasMovement) {
    height += 18;
  }

  return height > 0 ? height + 8 : 0;
}

/** Estimate footer block height from footer text and page-number settings. */
function estimateFooterHeight(config: LayoutPlanConfig): number {
  const hasFooterText =
    Boolean(config.leftFooter) || Boolean(config.rightFooter) || config.showPageNumber;
  return hasFooterText ? 20 : 0;
}

/**
 * Build per-measure column widths for one system.
 * In paginated mode we fit columns to content width; in continuous mode we
 * preserve a long horizontal layout with baseline widths.
 */
function buildMeasureColumnLayoutForSystem(
  score: Score,
  partLayouts: PartLayout[],
  system: SystemRange,
  contentStartX: number,
  availableWidth: number,
  fitToWidth: boolean,
  justifySystem: boolean,
  diagnostics: Diagnostic[]
): MeasureColumnLayout {
  const measureCount = Math.max(1, system.endMeasure - system.startMeasure);
  const sourceWidthHints = resolveSystemMeasureWidthHints(partLayouts, system);
  const columnWidths = initializeSystemColumnWidths(
    measureCount,
    availableWidth,
    fitToWidth,
    sourceWidthHints
  );
  const firstBaseWidth =
    columnWidths[0] ??
    (fitToWidth
      ? Math.max(MINIMUM_FITTED_MEASURE_WIDTH, Math.floor(availableWidth / measureCount))
      : MINIMUM_MEASURE_WIDTH);
  const firstExtra = estimateSystemStartExtraWidth(score, partLayouts, system.startMeasure, firstBaseWidth, diagnostics);
  columnWidths[0] = firstBaseWidth + firstExtra;

  if (fitToWidth) {
    if (justifySystem) {
      expandColumnWidthsToFit(columnWidths, availableWidth);
    } else {
      shrinkColumnWidthsToFit(columnWidths, availableWidth);
    }
  }

  const columnX: number[] = [];
  let cursor = contentStartX;
  for (const width of columnWidths) {
    columnX.push(cursor);
    cursor += width;
  }

  return {
    columnX,
    columnWidths,
    totalWidth: cursor - contentStartX
  };
}

/**
 * Resolve one source-width hint per system column from MusicXML `measure@width`.
 * We use median-of-parts to avoid one-part outliers dominating column allocation.
 */
function resolveSystemMeasureWidthHints(
  partLayouts: PartLayout[],
  system: SystemRange
): Array<number | undefined> {
  const widthHints: Array<number | undefined> = [];

  for (let measureIndex = system.startMeasure; measureIndex < system.endMeasure; measureIndex += 1) {
    const perPartWidths: number[] = [];
    for (const layout of partLayouts) {
      const widthTenths = layout.part.measures[measureIndex]?.sourceWidthTenths;
      if (Number.isFinite(widthTenths) && (widthTenths ?? 0) > 0) {
        perPartWidths.push(widthTenths ?? 0);
      }
    }

    if (perPartWidths.length === 0) {
      widthHints.push(undefined);
      continue;
    }

    widthHints.push(medianNumber(perPartWidths));
  }

  return widthHints;
}

/**
 * Build initial system column widths.
 * When source width hints exist, we preserve their relative proportions and then
 * normalize to available width; otherwise we fall back to uniform widths.
 */
function initializeSystemColumnWidths(
  measureCount: number,
  availableWidth: number,
  fitToWidth: boolean,
  sourceWidthHints: Array<number | undefined>
): number[] {
  if (!fitToWidth) {
    return Array.from({ length: measureCount }, () => MINIMUM_MEASURE_WIDTH);
  }

  const uniformWidth = Math.max(MINIMUM_FITTED_MEASURE_WIDTH, Math.floor(availableWidth / measureCount));
  const validHints = sourceWidthHints.filter(
    (hint): hint is number => typeof hint === 'number' && Number.isFinite(hint) && hint > 0
  );
  if (validHints.length < 2) {
    return Array.from({ length: measureCount }, () => uniformWidth);
  }

  const fallbackHint = medianNumber(validHints);
  const normalizedHints = sourceWidthHints.map((hint) =>
    Number.isFinite(hint) && (hint ?? 0) > 0 ? (hint ?? fallbackHint) : fallbackHint
  );
  const hintSum = normalizedHints.reduce((sum, hint) => sum + hint, 0);
  if (!Number.isFinite(hintSum) || hintSum <= 0) {
    return Array.from({ length: measureCount }, () => uniformWidth);
  }

  return normalizedHints.map((hint) =>
    Math.max(MINIMUM_FITTED_MEASURE_WIDTH, Math.round((availableWidth * hint) / hintSum))
  );
}

/** Estimate system-start modifier overhead for clef/key/time signature reservation. */
function estimateSystemStartExtraWidth(
  score: Score,
  layouts: PartLayout[],
  startMeasure: number,
  baseMeasureWidth: number,
  diagnostics: Diagnostic[]
): number {
  const plainShift = noteStartShiftForStave(baseMeasureWidth, undefined, undefined, undefined);
  let maxExtraShift = 0;

  for (const layout of layouts) {
    const measure = layout.part.measures[startMeasure];
    if (!measure) {
      continue;
    }

    for (let staffNumber = 1; staffNumber <= layout.staffCount; staffNumber += 1) {
      const clefInfo = resolveClefForStaff(measure, staffNumber);
      const clef = mapClef(clefInfo, diagnostics);
      const key = staffNumber === 1 ? mapKeySignature(measure.effectiveAttributes.keySignature) : undefined;
      const time = staffNumber === 1 ? mapTimeSignature(measure.effectiveAttributes.timeSignature) : undefined;
      const shiftedStart = noteStartShiftForStave(baseMeasureWidth, clef, key, time);
      const extraShift = Math.max(0, shiftedStart - plainShift);
      maxExtraShift = Math.max(maxExtraShift, extraShift);
    }
  }

  if (!Number.isFinite(maxExtraShift)) {
    return 0;
  }

  // Raw shift-to-extra mapping tends to over-expand opening measures in dense
  // multi-part systems. We damp, ignore a small baseline shift, and cap relative
  // to the measure width so this remains readable across both simple and complex
  // fixtures without hard-coding case-specific behavior.
  const rawExtra = Math.ceil(maxExtraShift);
  const dampedExtra = Math.ceil(rawExtra * FIRST_COLUMN_EXTRA_WIDTH_DAMPING);
  const ignoredBaseline = Math.floor(baseMeasureWidth * FIRST_COLUMN_EXTRA_IGNORE_RATIO);
  const cap = Math.floor(baseMeasureWidth * FIRST_COLUMN_EXTRA_WIDTH_CAP_RATIO);
  const adjustedExtra = Math.max(0, dampedExtra - ignoredBaseline);

  return Math.min(adjustedExtra, Math.max(0, cap));
}

/**
 * Expand measure widths to consume available system width.
 * This improves justification consistency for non-final systems.
 */
function expandColumnWidthsToFit(widths: number[], targetWidth: number): void {
  if (widths.length === 0) {
    return;
  }

  const total = widths.reduce((sum, width) => sum + width, 0);
  if (total >= targetWidth) {
    shrinkColumnWidthsToFit(widths, targetWidth);
    return;
  }

  let remaining = targetWidth - total;
  let cursor = 0;
  while (remaining > 0) {
    widths[cursor % widths.length] = (widths[cursor % widths.length] ?? 0) + 1;
    remaining -= 1;
    cursor += 1;
  }
}

/** Shrink measure widths when system content exceeds available width. */
function shrinkColumnWidthsToFit(widths: number[], targetWidth: number): void {
  const total = widths.reduce((sum, width) => sum + width, 0);
  if (total <= targetWidth) {
    return;
  }

  let overflow = total - targetWidth;
  let cursor = widths.length - 1;
  while (overflow > 0) {
    const width = widths[cursor];
    if (width !== undefined && width > MINIMUM_FITTED_MEASURE_WIDTH) {
      widths[cursor] = width - 1;
      overflow -= 1;
    }

    cursor -= 1;
    if (cursor < 0) {
      cursor = widths.length - 1;
      const cannotShrinkFurther = widths.every((value) => value <= MINIMUM_FITTED_MEASURE_WIDTH);
      if (cannotShrinkFurther) {
        break;
      }
    }
  }
}

/** Compute a numeric median for stable width-hint aggregation. */
function medianNumber(values: number[]): number {
  if (values.length === 0) {
    return 0;
  }

  const sorted = [...values].sort((left, right) => left - right);
  const middle = Math.floor(sorted.length / 2);
  const middleValue = sorted[middle];
  if (middleValue === undefined) {
    return 0;
  }

  if (sorted.length % 2 === 1) {
    return middleValue;
  }

  const previous = sorted[middle - 1];
  if (previous === undefined) {
    return middleValue;
  }

  return (previous + middleValue) / 2;
}

/**
 * Compute how far note entry begins from stave `x` for a given modifier set.
 * This helper intentionally does not draw; it only inspects deterministic
 * VexFlow stave spacing internals.
 */
function noteStartShiftForStave(
  width: number,
  clef: string | undefined,
  key: string | undefined,
  time: string | undefined
): number {
  const probe = new Stave(0, 0, width);
  if (clef) {
    probe.addClef(clef);
  }
  if (key) {
    probe.addKeySignature(key);
  }
  if (time) {
    probe.addTimeSignature(time);
  }

  return probe.getNoteStartX() - probe.getX();
}

/** Draw page-level titles, headers, footers, and page numbers. */
function drawPageHeaderFooter(
  context: ReturnType<Renderer['getContext']>,
  score: Score,
  pageNumber: number,
  pageCount: number,
  pageWidth: number,
  pageHeight: number,
  config: LayoutPlanConfig
): void {
  const headerTop = config.margins.top;
  const footerY = pageHeight - Math.max(10, config.margins.bottom - 12);
  const headerLineCount = Math.max(countTextLines(config.leftHeader), countTextLines(config.rightHeader));
  const headerBlockHeight = headerLineCount > 0 ? headerLineCount * 12 + 4 : 0;
  const titleTop = headerTop + (headerBlockHeight > 0 ? headerBlockHeight + 18 : 22);

  if (pageNumber === 1 && config.showTitle && score.metadata?.workTitle) {
    drawText(context, score.metadata.workTitle, centerX(pageWidth, score.metadata.workTitle, 20), titleTop, 20, 'bold');
  }

  if (pageNumber === 1 && config.showMovementTitle && score.metadata?.movementTitle) {
    drawText(
      context,
      score.metadata.movementTitle,
      centerX(pageWidth, score.metadata.movementTitle, 14),
      titleTop + 22,
      14,
      'normal'
    );
  }

  if (config.leftHeader) {
    drawText(context, config.leftHeader, config.margins.left, headerTop + 12, 11, 'normal');
  }
  if (config.rightHeader) {
    const x = pageWidth - config.margins.right - estimateTextWidth(config.rightHeader, 11);
    drawText(context, config.rightHeader, x, headerTop + 12, 11, 'normal');
  }

  if (config.leftFooter) {
    drawText(context, config.leftFooter, config.margins.left, footerY, 11, 'normal');
  }
  if (config.rightFooter) {
    const x = pageWidth - config.margins.right - estimateTextWidth(config.rightFooter, 11);
    drawText(context, config.rightFooter, x, footerY, 11, 'normal');
  }

  if (config.showPageNumber) {
    const label = `${pageNumber}${pageCount > 1 ? ` / ${pageCount}` : ''}`;
    const x = pageWidth - config.margins.right - estimateTextWidth(label, 11);
    drawText(context, label, x, footerY, 11, 'normal');
  }
}

/** Draw one part label at the left edge of the system start. */
function drawPartLabel(
  context: ReturnType<Renderer['getContext']>,
  definition: PartDefinition | undefined,
  systemIndex: number,
  y: number,
  config: LayoutPlanConfig
): void {
  if (config.labelWidth <= 0) {
    return;
  }

  const isFirstSystem = systemIndex === 0;
  const label = resolvePartLabel(definition, isFirstSystem, config);
  if (!label) {
    return;
  }

  const x = config.contentStartX - config.labelWidth + 6;
  drawText(context, label, x, y, 12, isFirstSystem ? 'bold' : 'normal');
}

/** Resolve label text for first and repeated system starts. */
function resolvePartLabel(
  definition: PartDefinition | undefined,
  isFirstSystem: boolean,
  config: LayoutPlanConfig
): string | undefined {
  if (!definition) {
    return undefined;
  }

  if (isFirstSystem && config.showPartNames) {
    return definition.name ?? definition.abbreviation ?? undefined;
  }

  if (!isFirstSystem && !config.repeatOnSystemBreak) {
    return undefined;
  }

  if (config.showPartAbbreviations) {
    return definition.abbreviation ?? definition.name ?? undefined;
  }

  if (config.showPartNames) {
    return definition.name ?? undefined;
  }

  return undefined;
}

/** Render one text label using deterministic font settings. */
function drawText(
  context: ReturnType<Renderer['getContext']>,
  text: string,
  x: number,
  y: number,
  fontSize: number,
  weight: 'normal' | 'bold'
): void {
  if (text.length === 0) {
    return;
  }

  context.setFont('Times New Roman', fontSize, weight);
  const lineHeight = fontSize + 2;
  const lines = text.split('\n');
  for (let index = 0; index < lines.length; index += 1) {
    const line = lines[index];
    if (!line) {
      continue;
    }
    context.fillText(line, x, y + index * lineHeight);
  }
}

/** Approximate centered text X coordinate from simple width heuristics. */
function centerX(pageWidth: number, text: string, fontSize: number): number {
  return Math.max(0, (pageWidth - estimateTextWidth(text, fontSize)) / 2);
}

/** Estimate text width without relying on browser text metrics. */
function estimateTextWidth(text: string, fontSize: number): number {
  const lines = text.split('\n');
  let maxWidth = 0;
  for (const line of lines) {
    maxWidth = Math.max(maxWidth, Math.ceil(line.length * fontSize * TEXT_WIDTH_FACTOR));
  }
  return maxWidth;
}

/** Count rendered text lines for multiline-aware header/layout calculations. */
function countTextLines(text: string | undefined): number {
  if (!text) {
    return 0;
  }

  return Math.max(1, text.split('\n').filter((line) => line.length > 0).length);
}

/**
 * Format one voice against the stave's computed note area instead of a fixed width.
 * This prevents first-column collisions where clef/time/key modifiers consume
 * horizontal space and leaves too little room for tickables.
 */
function formatVoiceToStave(
  voice: Voice,
  stave: Stave,
  diagnostics: Diagnostic[],
  measureIndex: number,
  staffNumber: number
): void {
  try {
    new Formatter().joinVoices([voice]).formatToStave([voice], stave, { align_rests: true });
  } catch (error) {
    diagnostics.push({
      code: 'VOICE_FORMAT_FAILED',
      severity: 'warning',
      message: `Measure ${measureIndex + 1}, staff ${staffNumber} failed stave-aware formatting (${String(error)}).`
    });

    // Fallback preserves deterministic rendering even when VexFlow formatting throws.
    const fallbackWidth = Math.max(32, stave.getWidth() - 30);
    new Formatter().joinVoices([voice]).format([voice], fallbackWidth, { align_rests: true });
  }
}

/** Beam-group construction result used to hide flags before `voice.draw()`. */
interface PreparedMeasureBeams {
  beams: Beam[];
}

/**
 * Prepare beam groups before drawing notes.
 * This is critical: VexFlow suppresses per-note flags when notes already carry
 * beam attachments at draw time.
 */
function prepareMeasureBeams(
  measure: Measure,
  notes: StaveNote[],
  noteByEventKey: Map<string, StaveNote>,
  diagnostics: Diagnostic[],
  measureIndex: number,
  staffNumber: number
): PreparedMeasureBeams {
  if (notes.length < 2) {
    return {
      beams: []
    };
  }

  try {
    const sourceBeamGroups = collectSourceBeamGroups(measure, noteByEventKey, staffNumber);
    if (sourceBeamGroups && sourceBeamGroups.length > 0) {
      return {
        beams: sourceBeamGroups.map((group) => new Beam(group))
      };
    }

    const beams = Beam.generateBeams(notes, {
      beam_rests: false,
      maintain_stem_directions: true,
      show_stemlets: false
    });

    return {
      beams
    };
  } catch (error) {
    diagnostics.push({
      code: 'BEAM_RENDER_FAILED',
      severity: 'warning',
      message: `Measure ${measureIndex + 1}, staff ${staffNumber} beam generation failed (${String(error)}).`
    });
    return {
      beams: []
    };
  }
}

/** Draw already prepared beams after voice noteheads/stems have been rendered. */
function drawPreparedBeams(
  prepared: PreparedMeasureBeams,
  context: ReturnType<Renderer['getContext']>,
  diagnostics: Diagnostic[],
  measureIndex: number,
  staffNumber: number
): void {
  for (const beam of prepared.beams) {
    try {
      beam.setContext(context).draw();
    } catch (error) {
      diagnostics.push({
        code: 'BEAM_RENDER_FAILED',
        severity: 'warning',
        message: `Measure ${measureIndex + 1}, staff ${staffNumber} beam drawing failed (${String(error)}).`
      });
    }
  }
}

/** One source beam-group extraction outcome. */
interface SourceBeamGroupExtraction {
  groups: StaveNote[][];
  beamedNoteCount: number;
  groupedNoteCount: number;
  unsupported: boolean;
}

/**
 * Build beam groups from authored MusicXML beam markers (level 1 only).
 * Returns `undefined` when source markers are incomplete/unsupported so callers
 * can safely fall back to VexFlow auto-beaming.
 */
function collectSourceBeamGroups(
  measure: Measure,
  noteByEventKey: Map<string, StaveNote>,
  staffNumber: number
): StaveNote[][] | undefined {
  const extraction = extractSourceBeamGroups(measure, noteByEventKey, staffNumber);
  if (extraction.unsupported) {
    return undefined;
  }

  if (extraction.groups.length === 0 || extraction.groupedNoteCount !== extraction.beamedNoteCount) {
    return undefined;
  }

  return extraction.groups;
}

/** Extract source beam groups and coverage counters for fallback decisions. */
function extractSourceBeamGroups(
  measure: Measure,
  noteByEventKey: Map<string, StaveNote>,
  staffNumber: number
): SourceBeamGroupExtraction {
  const groups: StaveNote[][] = [];
  let beamedNoteCount = 0;
  let groupedNoteCount = 0;
  let unsupported = false;

  for (const voice of measure.voices) {
    let activeGroup: StaveNote[] = [];

    const flushActiveGroup = (): void => {
      if (activeGroup.length >= 2) {
        groups.push(activeGroup);
        groupedNoteCount += activeGroup.length;
      }
      activeGroup = [];
    };

    for (let eventIndex = 0; eventIndex < voice.events.length; eventIndex += 1) {
      const event = voice.events[eventIndex];
      if (!event || event.kind !== 'note') {
        continue;
      }

      if ((event.staff ?? 1) !== staffNumber) {
        continue;
      }

      const note = noteByEventKey.get(buildVoiceEventKey(voice.id, eventIndex));
      if (!note) {
        continue;
      }

      const beam = event.beams?.find((candidate) => candidate.number === 1);
      if (!beam) {
        flushActiveGroup();
        continue;
      }

      beamedNoteCount += 1;

      switch (beam.value) {
        case 'begin': {
          flushActiveGroup();
          activeGroup = [note];
          break;
        }
        case 'continue': {
          if (activeGroup.length === 0) {
            activeGroup = [note];
          } else {
            activeGroup.push(note);
          }
          break;
        }
        case 'end': {
          if (activeGroup.length === 0) {
            activeGroup = [note];
          } else {
            activeGroup.push(note);
          }
          flushActiveGroup();
          break;
        }
        case 'forward hook':
        case 'backward hook': {
          // Single-note hook beams are not reconstructed yet; mark as unsupported
          // so the caller can use automatic beaming for this measure/staff.
          unsupported = true;
          flushActiveGroup();
          break;
        }
      }
    }

    if (activeGroup.length >= 2) {
      groups.push(activeGroup);
      groupedNoteCount += activeGroup.length;
    }
  }

  return {
    groups,
    beamedNoteCount,
    groupedNoteCount,
    unsupported
  };
}

/** Apply repeat-barline and volta metadata to a stave before drawing. */
function applyMeasureBarlineSemantics(stave: Stave, measure: Measure, staffNumber: number): void {
  const barlines =
    measure.barlines && measure.barlines.length > 0 ? measure.barlines : measure.barline ? [measure.barline] : [];
  if (barlines.length === 0) {
    return;
  }

  let hasForwardRepeat = false;
  let hasBackwardRepeat = false;
  let endingStart = false;
  let endingMid = false;
  let endingStop = false;
  let endingLabel = '';

  for (const barline of barlines) {
    for (const repeat of barline.repeats ?? []) {
      if (repeat.direction === 'forward' && repeat.location === 'left') {
        hasForwardRepeat = true;
      }
      if (repeat.direction === 'backward' && repeat.location === 'right') {
        hasBackwardRepeat = true;
      }
    }

    for (const ending of barline.endings ?? []) {
      if (!endingLabel) {
        endingLabel = ending.number ?? ending.text ?? '';
      }
      if (ending.type === 'start') {
        endingStart = true;
      }
      if (ending.type === 'continue') {
        endingMid = true;
      }
      if (ending.type === 'stop' || ending.type === 'discontinue') {
        endingStop = true;
      }
    }
  }

  if (hasForwardRepeat) {
    stave.setBegBarType(BarlineType.REPEAT_BEGIN);
  }

  if (hasBackwardRepeat) {
    stave.setEndBarType(hasForwardRepeat ? BarlineType.REPEAT_BOTH : BarlineType.REPEAT_END);
  }

  if (staffNumber === 1) {
    if (endingStart && endingStop) {
      stave.setVoltaType(VoltaType.BEGIN_END, endingLabel, 8);
    } else if (endingStart) {
      stave.setVoltaType(VoltaType.BEGIN, endingLabel, 8);
    } else if (endingMid) {
      stave.setVoltaType(VoltaType.MID, endingLabel, 8);
    } else if (endingStop) {
      stave.setVoltaType(VoltaType.END, endingLabel, 8);
    }
  }
}

/** Draw a stave connector between top and bottom staves for a given style. */
function drawConnector(
  topStave: Stave,
  bottomStave: Stave,
  type: StaveConnectorType,
  context: ReturnType<Renderer['getContext']>
): void {
  new StaveConnector(topStave, bottomStave).setType(type).setContext(context).draw();
}

/** Draw part-group connectors derived from parsed part-list group metadata. */
function drawPartGroupConnectors(
  score: Score,
  layouts: PartLayout[],
  boundaries: Map<string, PartBoundary>,
  context: ReturnType<Renderer['getContext']>
): number {
  const partOrder = new Map(layouts.map((layout, index) => [layout.part.id, index]));
  const ranges = new Map<string, { start: number; end: number }>();

  for (const partDefinition of score.partList) {
    const partIndex = partOrder.get(partDefinition.id);
    if (partIndex === undefined || !partDefinition.groupPath) {
      continue;
    }

    for (const token of partDefinition.groupPath) {
      const range = ranges.get(token);
      if (!range) {
        ranges.set(token, { start: partIndex, end: partIndex });
      } else {
        range.start = Math.min(range.start, partIndex);
        range.end = Math.max(range.end, partIndex);
      }
    }
  }

  let count = 0;
  for (const [token, range] of ranges.entries()) {
    const connectorType = mapGroupTokenToConnector(token);
    if (!connectorType) {
      continue;
    }

    const startPart = layouts[range.start]?.part.id;
    const endPart = layouts[range.end]?.part.id;
    if (!startPart || !endPart) {
      continue;
    }

    const startBoundary = boundaries.get(startPart);
    const endBoundary = boundaries.get(endPart);
    if (!startBoundary || !endBoundary) {
      continue;
    }

    drawConnector(startBoundary.topStave, endBoundary.bottomStave, connectorType, context);
    count += 1;
  }

  return count;
}

/** Map serialized group-path tokens to VexFlow stave connector types. */
function mapGroupTokenToConnector(token: string): StaveConnectorType | undefined {
  const symbol = token.includes(':') ? token.slice(token.indexOf(':') + 1) : token;
  switch (symbol) {
    case 'brace':
      return 'brace';
    case 'line':
      return 'singleLeft';
    case 'none':
      return undefined;
    case 'bracket':
    default:
      return 'bracket';
  }
}

/** Clamp nullable/numeric values to deterministic integer bounds. */
function clampInt(value: number, minimum: number, maximum: number): number {
  const rounded = Math.round(value);
  return Math.max(minimum, Math.min(maximum, rounded));
}
